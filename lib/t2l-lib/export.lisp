(in-package :t2l)

(defvar *export1-register-midic-assoc* nil)
(setf 
 (cdr-assoc -1 *export1-register-midic-assoc*) '(55 85)

; vln
 (cdr-assoc 0 *export1-register-midic-assoc*)
 (list 
  (cons 1 '(55 70)) ; 55 74
  (cons 2 '(60 75)) ; 63 78
  (cons 3 '(66 82)) ; 70 85
  (cons 4 '(71 88))); 77 89
; vln 2
 (cdr-assoc 1 *export1-register-midic-assoc*) 
 (cdr-assoc 0 *export1-register-midic-assoc*)
; vla
 (cdr-assoc 2 *export1-register-midic-assoc*)
 (list 
  (cons 1 '(48 58)) ; 48 65
  (cons 2 '(53 63)) ; 56 70
  (cons 3 '(59 68)) ; 63 78
  (cons 4 '(64 77))); 70 85
; vla 2
 (cdr-assoc 3 *export1-register-midic-assoc*) 
 (cdr-assoc 2 *export1-register-midic-assoc*)
; vc
 (cdr-assoc 4 *export1-register-midic-assoc*)
 (list 
  (cons 1 '(36 51))
  (cons 2 '(44 58))
  (cons 3 '(52 65))
  (cons 4 '(59 77)))
; vc 2
 (cdr-assoc 5 *export1-register-midic-assoc*) 
 (cdr-assoc 4 *export1-register-midic-assoc*)
; ob
 (cdr-assoc 6 *export1-register-midic-assoc*)
 (list 
  (cons 1 '(59 68))
  (cons 2 '(66 75))
  (cons 3 '(68 80))
  (cons 4 '(80 90)))
; cl
 (cdr-assoc 7 *export1-register-midic-assoc*)
 (list 
  (cons 1 '(51 64))
  (cons 2 '(59 68))
  (cons 3 '(69 82))
  (cons 4 '(76 89)))
)

(defun export1-seqc-d-cspvar-function-timevars (beats figures &key (level 0) (max-process-levels 2) (beat-min 1))
  (cond
   ((null beats) nil) 
   ((>= level max-process-levels) beats)
   (t
    (append
     (list
      (either 
        (progn
          (unless (>= (car beats) beat-min) (fail))
          (let ((f (a-random-member-of figures)))
            (if (null f)
                (car beats)
              (list (car beats)
                    (export1-seqc-d-cspvar-function-timevars f
                                                             figures
                                                             :level (1+ level)
                                                             :max-process-levels max-process-levels
                                                             :beat-min beat-min)))))
        (car beats)))
     (export1-seqc-d-cspvar-function-timevars (cdr beats)
                                              figures
                                              :level level
                                              :max-process-levels max-process-levels
                                              :beat-min beat-min)))))
        
(defun export1-seqc-d-list-expansion (templates total)
 (let ((l1 (flat (an-expanded-list templates
                             #'(lambda (x) (>= (apply #'+ (flat x)) 7))
                             :randomize-choices t))))
   (let ((i (an-integer-between 1 (length l1))))
     (unless (>= (apply #'+ (subseq l1 0 i)) total) (fail))
     (mapcar #'floor (subseq l1 0 i)))))
      

(defun export1-seqc-d-cspvar-function-internal (obj modulus)
  (let ((msbeats (ms-beat-count (measures obj) modulus))
        (figures (or (cdr-assoc :figures (params obj))
                     '((1 1)
                       (1 2)
                       (1 3))))
        (process-mode (or (cdr-assoc :process-mode (params obj)) 0)))   
    (print (format nil "~A beats ms: ~A" msbeats (measures obj)))
    (export1-seqc-d-cspvar-function-timevars 
     (cond
      ((= process-mode 0)
       (export1-seqc-d-list-expansion (or (cdr-assoc :template (params obj)) figures)
                                      msbeats))
      ((= process-mode 1)
       (car (partn-list '(2 1) (list msbeats))))
      (t
       (export1-seqc-d-list-expansion (or (cdr-assoc :template (params obj)) figures) msbeats)))                                             
     figures
     :max-process-levels (or (cdr-assoc :max-process-levels (params obj)) 2)
     :beat-min (or (cdr-assoc :beat-min (params obj)) 1))))
  
(defun export1-seqc-d-cspvar-function (obj)
  (print (format nil "export1-seqc-d-cspvar-function params: ~A" (params obj)))
  (let ((modulus (or (modulus obj)
                     (cdr-assoc :modulus (params obj))
                     '(8 (1 1)))))
    (let ((timesoln 
           (one-value
            (let* ((s (solution (export1-seqc-d-cspvar-function-internal obj modulus) (static-ordering #'linear-force)))
                   (s-enp 
                    (progn
                      (print (format nil "export1-seqc-d-cspvar-function scale-seqc-timepoints call s: ~A measures: ~A modulus: ~A enp: ~A" (list s) (measures obj) modulus t))
                      (scale-seqc-timepoints (list s) (measures obj) modulus :enp t)))
                   (groups (mapcar #'enp-part-groups s-enp))
                   (group-elems (remove nil (flat groups))))
              (print (format nil "s-enp: ~A" s-enp))
              (print (format nil "group-elems: ~A" group-elems))
              (print (format nil "s: ~A" s))
              (assert! (reduce #'andv (mapcar #'(lambda (x) (<=v x (or (cdr-assoc :enp-group-max (params obj)) 10))) group-elems)))
              s))))
      (print (format nil "timesoln: ~A" timesoln))        
      (let ((tree (car (scale-seqc-timepoints (list timesoln) (measures obj) modulus))))
        (let ((midics 
               (mapcar
                #'(lambda (x) 60)
                (om:get-pulse-places tree)))
              (tratios nil))
          (list (cons :timepoints timesoln)
                (cons :midics midics)))))))
  
(defvar *export1-enppar-assoc* nil)
(setf
 (cdr-assoc :A *export1-enppar-assoc*)
 #'(lambda (list)
     (let ((reg (or (cdr-assoc :register list)
                    (cdr-assoc :reg list)
                    -1))
           (index (or (cdr-assoc :index list) 0)))
       (make-instance
        'export1-timepoint-seqc-voice
        :csp-rules nil
        
                        
        :modulus (or (cdr-assoc :modulus list) '(8 (1 1)))
        :params (mergeassoc
                 list
                 (list 
                  (or (cdr-assoc :midicrules list)
                      (append
                       (list :midicrules)
                       '((:S :C)
                         (:S :D)
                         (:C 2)
                         (:C -3)
                         (:C -3 :C)
                         (:C :C 4 1 :C)
                         (:C :C -1 :C)
                         (:C 5 :D -5)
                         (:D -2)
                         (:D 3)
                         (:D 3 :D)
                         (:D :D -4 -1 :D)
                         (:D :D 2 :D)
                         (:D 8 :D -3)
                         (:D 9 :D -3)
                         (:D 9 :D -4))))
                  (cons :continue t)
                  (cons :mapprules-input-process-increment nil) ;9
                  (cons :mapprules-nondeterministic-values-cap nil) ;8
                  (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                  (cons :midic-min (apply #'min (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))
                  (cons :midic-max (apply #'max (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg))))))))))))
 (cdr-assoc :ASEQ *export1-enppar-assoc*)
 #'(lambda (list)
     (make-instance 'export1-timepoint-seqc 
                    :enps (mapcar 
                          #'(lambda (es)
                              (make-instance
                               'multi-enppar
                               :enps (list es)))
                          (cdr-assoc :enps list))
                    :csp-rules #'(lambda (params)
                                   (print (apply #'concatenate (append (list 'string 
                                                                             "---***********************---"
                                                                             (format nil "calling ASEQ csp-rules params: ~%"))
                                                                       (mapcar #'(lambda (x) (format nil " ~A~%" x)) params))))
                                   (print (format nil "voices: (~A)" (length (cdr-assoc :midics params))))
                                   (andv  
                                    (apply
                                     #'andv
                                     (mapcar #'(lambda (xs)
                                                 (apply
                                                  #'andv
                                                  (mapcar
                                                   #'(lambda (ys)
                                                       (let ((ms (car ys))
                                                             (s (mapcar #'(lambda (x) (integer-absv (if (listp x) (car x) x)))
                                                                        (cadr ys))))
                                                         #|(print (format nil "dddddddddddddddddddddddddddddd"))|#
                                                         #|(mapcar #'print s)|#
                                                         #|(assert (every #'atom s))|#
                                                         (=v (modv (apply #'+v s) (car ms)) 0)))
                                                   xs)))
                                             (cdr-assoc :timepoints params)))
                                    #|(seqcx-ival-countv (cdr-assoc :midics params)
                                                       '((0 0.18)
                                                         (1 0.3)
                                                         (2 0.45)))|#
                                    (let ((p (a-member-ofv '(55 62 69))))
                                      (apply
                                       #'andv
                                       (mapcar #'(lambda (s)
                                                   (seqcx-ival-countv (list s p)
                                                                      '((1 .12)
                                                                        (2 .3))))
                                               (cdr-assoc :midics params))))                                      
                                    (labels
                                        ((list-structure (x) (funcall-rec #'(lambda (y) (cond ((null y) nil) (t 'x))) x))
                                         (chunk-rule (vs n)                                
                                           (print (format nil "chunk-rule vs: ~A n: ~A" vs n))
                                           (reduce
                                            #'andv
                                            (print
                                             (mapcar
                                              #'(lambda (chunk)
                                                  (print (format nil " >> c: ~A" chunk))
                                                  (orv (apply #'<v chunk) ;
                                                       (apply #'>v chunk)))
                                              (nsucc (remove nil (flat vs)) n))))))
                                      (apply 
                                       #'andv
                                       (mapcar
                                        #'(lambda (list)
                                            (apply 
                                             #'andv
                                             (remove 
                                              nil
                                              (flat
                                               (funcall-rec
                                                #'(lambda (x)
                                                    (print (format nil "export1 oK>>> ~A" (list-structure x)))
                                                    (let ((y (remove nil (flat x))))
                                                      (cond
                                                       ((null y) t)
                                                       ((> (length y) 4)
                                                        (orv (chunk-rule y 4)
                                                             (chunk-rule y 3)))
                                                       ((and (> (length y) 1)
                                                             (< (length y) 5))
                                                        (orv (apply #'<=v y)
                                                             (apply #'>=v y)))
                                                       (t t))))
                                                list
                                                :cons-mode t
                                                :level-min 1)))))
                                        (cdr-assoc :midics params))))))
                    :measures (cdr-assoc :measures list)
                    :modulus (or (cdr-assoc :modulus list) '(8 (1 1)))
                    :params list))
 (cdr-assoc :CSPTECH1 *export1-enppar-assoc*)
 #'(lambda (list)
     (make-instance 
      'csptech-timepoint-seqc
      :cspvar-function #'(lambda (obj)
                           (list (cons :midics '((64 65 67 69 71)
                                                 (60 62 64 65 67)))
                                 (cons :timepoints (scale-seqc-timepoints '((1 1 1 1 4)
                                                                            (1 1 1 1 4))
                                                                          (measures obj)
                                                                          '(4 (1 1))))))))

 (cdr-assoc :EXPAND-FN0 *export1-enppar-assoc*)
 #'(lambda (list)
     #'(lambda (&rest params)
         nil))
 (cdr-assoc :EXPAND-FN1 *export1-enppar-assoc*)
 #'(lambda (list)
     (let ((expand-voices (cdr-assoc :expand-voices list)))
       #'(lambda (&rest params)
           (let ((midic (cdr-assoc :midic params))
                 (midics (cdr-assoc :midics params))
                 (midic-index (cdr-assoc :midic-index params))
                 (timepoint (cdr-assoc :timepoint params))
                 (timepoints (cdr-assoc :timepoints params))
                 (timepoint-index (cdr-assoc :timepoint-index params))
                 (index (cdr-assoc :index params))
                 (part-index (cdr-assoc :part-index params))
                 (enppar (cdr-assoc :enppar params))
                 (seqc-enppar (cdr-assoc :seqc-enppar params))
                 (out-params nil))
             (print (format nil "FSEQ expand-function PART-INDEX ~A midics ~A min: ~A max: ~A" part-index midics (cdr-assoc :midic-min params) (cdr-assoc :midic-max params)))
             (unless (or (< timepoint 4))
               (print (format nil "FSEQ expand-function paramssssssss ~A" params))
               (let* ((count (random-list-e '(3 5)))
                      (midicvars (mapprules (make-sequence 'list count :initial-element '_)
                                            '((:S :C)
                                              (:S :D)
                                              (:S :S :S)
                                              (:C :E)
                                              (:C :F)
                                              (:C :C :C)
                                              (:D :J)
                                              (:D :K)
                                              (:D :D :D)
                                              (:E -4 -1)
                                              (:E -3 -2)
                                              (:E -3 -1)
                                              (:E -2 -2)
                                              (:E -2 -1)
                                              (:F 4 1)
                                              (:F 3 2)
                                              (:F 3 1)
                                              (:F 2 2)
                                              (:F 2 1)
                                              (:J -3)
                                              (:J -2)
                                              (:K 3)
                                              (:K 2))
                                            :continue t
                                            :input-process-increment 4
                                            :listdxx t))
                      (timevars (append
                                 (mapcar #'(lambda (x) 1) (butlast midicvars))
                                 (list (an-integer-betweenv 3 8)))))
                 (assert! (let ((s (apply #'+v timevars)))
                            (andv (<=v s (*v timepoint 4))
                                  (>=v s (*v timepoint 2)))))
                 (assert! 
                  (apply
                   #'andv
                   (mapcar
                    #'(lambda (xs) (orv (apply #'<v xs) (apply #'>v xs)))
                    (nsucc (reverse midicvars) 3))))
                 (assert! (=v (last-atom midicvars) midic))
                 (setf (cdr-assoc :expand-midic out-params) midicvars)
                 (setf (cdr-assoc :expand-timepoint out-params) (list timepoint timevars))
                 out-params))))))
 (cdr-assoc :EXPAND-FN2 *export1-enppar-assoc*)
 (let ((exps nil))
   #'(lambda (list)
       #'(lambda (&rest params)
           (let ((midic (cdr-assoc :midic params))
                 (midics (cdr-assoc :midics params))
                 (midic-index (cdr-assoc :midic-index params))
                 (timepoint (cdr-assoc :timepoint params))
                 (timepoints (cdr-assoc :timepoints params))
                 (timepoint-index (cdr-assoc :timepoint-index params))
                 (index (cdr-assoc :index params))
                 (part-index (cdr-assoc :part-index params))
                 (enppar (cdr-assoc :enppar params))
                 (seqc-enppar (cdr-assoc :seqc-enppar params))
                 (out-params nil))
             (if (>= *mess* 5) (print (format nil "expand-fn2 called tv: ~A" timepoint)))
             (unless (< timepoint 4)
               (let* ((midicvars (mapcar
                                  #'(lambda (x)
                                      (a-member-ofv (cdr-assoc 0 *export1-ser0127-assoc*)))
                                  (make-sequence 'list (or (cdr-assoc :mcount list) 3))))
                      (timevars (append
                                 (mapcar #'(lambda (x) 1) (butlast midicvars))
                                 (list (an-integer-betweenv 3 8)))))
                 ;(assert! (let ((s (apply #'+v timevars)))
                 ;           (<=v s (*v timepoint 4))))
                 (assert! (=v (last-atom midicvars) midic))
                 (assert! (apply #'andv (mapcar #'(lambda (x) (<v (integer-absv x) 8)) (listdxv midicvars))))
                 (if (cdr-assoc :midic-min params) (assert! (apply #'andv (mapcar #'(lambda (x) (>=v x (cdr-assoc :midic-min params))) midicvars))))
                 (if (cdr-assoc :midic-max params) (assert! (apply #'andv (mapcar #'(lambda (x) (<=v x (cdr-assoc :midic-max params))) midicvars))))
                 (assert! 
                  (apply
                   #'andv
                   (mapcar
                    #'(lambda (xs) (orv (apply #'<v xs) (apply #'>v xs)))
                    (nsucc (reverse midicvars) (or (cdr-assoc :nsucc-partn list) 3)))))
                 (setf (cdr-assoc :expand-midic out-params) midicvars)
                 (setf (cdr-assoc :expand-timepoint out-params) (list timepoint timevars))
                 out-params))))))

 (cdr-assoc :EXPAND-FN-LIST1 *export1-enppar-assoc*)
 #'(lambda (list)
     (om:permut-random
      (list
       (funcall (cdr-assoc :EXPAND-FN2 *export1-enppar-assoc*) (list (cons :mcount 5) (cons :nsucc-partn 3)))
       (funcall (cdr-assoc :EXPAND-FN2 *export1-enppar-assoc*) (list (cons :mcount 5) (cons :nsucc-partn 2)))
       (funcall (cdr-assoc :EXPAND-FN2 *export1-enppar-assoc*) (list (cons :mcount 4) (cons :nsucc-partn 2)))
       (funcall (cdr-assoc :EXPAND-FN2 *export1-enppar-assoc*) (list (cons :mcount 3) (cons :nsucc-partn 2))))))
 (cdr-assoc :EXPAND-TEST-FN1 *export1-enppar-assoc*)
 #'(lambda (list)
     (let ((expand-voices (cdr-assoc :expand-voices list)))
       #'(lambda (&rest params)
           (let ((midic (cdr-assoc :midic params))
                 (midics (cdr-assoc :midics params))
                 (midic-index (cdr-assoc :midic-index params))
                 (timepoint (cdr-assoc :timepoint params))
                 (timepoints (cdr-assoc :timepoints params))
                 (timepoint-index (cdr-assoc :timepoint-index params))
                 (index (cdr-assoc :index params))
                 (part-index (cdr-assoc :part-index params))
                 (enppar (cdr-assoc :enppar params))
                 (seqc-enppar (cdr-assoc :seqc-enppar params))
                 (out-params nil))
             (print (format nil "FSEQ expand-function PART-INDEX ~A expand-voices ~A params ~A" part-index expand-voices params))
             (unless (or (< timepoint 4) (not (find part-index expand-voices)))
               (setf (cdr-assoc :expand-midic out-params) '(60 60 60))
               (setf (cdr-assoc :expand-timepoint out-params) (list timepoint (list 1 (an-integer-betweenv 2 3) 4)))
               out-params)))))
 (cdr-assoc :HSEQ *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((symbols (cdr-assoc :symbols params)))                
       (let ((obj (make-instance 
                   'timepoint-seqc-with-prules
                   :enps (mapcar 
                          #'(lambda (es)
                              (make-instance
                               'multi-enppar
                               :enps (list es)))
                          (cdr-assoc :enps params))
                   :measures (cdr-assoc :measures params)
                   :midic-csp-predicates 
                   ;nil
                   (list #'(lambda (seqc)
                             (seqcx-ival-countv seqc 
                                                '((0 .18)
                                                  (1 .45)
                                                  (2 .6)))))
                   :modulus (or (cdr-assoc :modulus params) '(8 (3 2)))
                   :params params
                   :time-csp-predicates (list #'seqc-voices-not-equalv)
                   ; (list #'(lambda (seqc) (seqc-n!pairs-/=v seqc))) ; seqc-voices-not-equalv
                   )))
         (setf (cdr-assoc :mapprules-incomplete-productions (params obj))
               (if (assoc :mapprules-incomplete-productions params)
                   (cdr-assoc :mapprules-incomplete-productions params)
                 nil))
         obj)))
 (cdr-assoc :HSEQ2 *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((obj (funcall (cdr-assoc :HSEQ *export1-enppar-assoc*) params)))
       (setf (midic-csp-predicates obj)
             (list #'(lambda (seqc)
                             (seqcx-ival-countv seqc 
                                                '((0 .13)
                                                  (1 .33)
                                                  (2 .6)
                                                  (3 -.05)
                                                  (4 -.05))))))
       obj))              
 (cdr-assoc :ISEQ *export1-enppar-assoc*)
 #'(lambda (params)
     (make-instance 'csptech-timepoint-seqc))
 (cdr-assoc :FSEQ *export1-enppar-assoc*)
 (let* ((expand-part-indexes nil))
   #'(lambda (params)
       (make-instance 
        'timepoint-seqc-expansion
        :expand-function (funcall (cdr-assoc (or (cdr-assoc :expand-fn params) :EXPAND-FN2) *export1-enppar-assoc*) params)
        :params params
        :proto (let ((proto (funcall (cdr-assoc :HSEQ *export1-enppar-assoc*) params)))
                 ;(setf (midic-csp-predicates proto)
                 ;      (list 
                 ;       #'(lambda (seqc)
                 ;           (seqcx-ival-countv seqc 
                 ;                              '((0 .05)
                 ;                                (1 .12)
                 ;                                (2 .22)
                 ;                                (6 .77))))))
                 ;(setf (time-csp-predicates proto)
                 ;      (list 
                 ;       #'seqc-voices-not-equalv))
                 proto))))
 (cdr-assoc :FSEQ2 *export1-enppar-assoc*)
 (let* ((expand-part-indexes nil))
   #'(lambda (params)
       (print (format nil "FSEQ params ~A" params))
       (make-instance 
        'timepoint-seqc-expansion
        :expand-function 
        #'(lambda (&rest params)
            (print (format nil "FSEQ expand-part-indexes ~A" expand-part-indexes))
            (let ((midic (cdr-assoc :midic params))
                  (midics (cdr-assoc :midics params))
                  (midic-index (cdr-assoc :midic-index params))
                  (timepoint (cdr-assoc :timepoint params))
                  (timepoints (cdr-assoc :timepoints params))
                  (timepoint-index (cdr-assoc :timepoint-index params))
                  (index (cdr-assoc :index params))
                  (part-index (cdr-assoc :part-index params))
                  (enppar (cdr-assoc :enppar params))
                  (seqc-enppar (cdr-assoc :seqc-enppar params))
                  (out-params nil))
              (print (format nil "FSEQ expand-function params ~A" params))
              (unless (< timepoint 5)                           
                (print (format nil "FSEQ expand-function expanding expand-part-indexes ~A" params))
                (push part-index expand-part-indexes)
                (let* ((count (om:om-random 4 7))
                       (midicvars (mapprules (make-sequence 'list count :initial-element '_)
                                             '((:S :C)
                                               (:S :D)
                                               (:S :S :S)
                                               (:C :E)
                                               (:C :F)
                                               (:C :C :C)
                                               (:D :J)
                                               (:D :K)
                                               (:D :D :D)
                                               (:E -4 -1)
                                               (:E -3 -2)
                                               (:E -3 -1)
                                               (:E -2 -2)
                                               (:E -2 -1)
                                               (:F 4 1)
                                               (:F 3 2)
                                               (:F 3 1)
                                               (:F 2 2)
                                               (:F 2 1)
                                               (:J -3)
                                               (:J -2)
                                               (:K 3)
                                               (:K 2))
                                             :continuation-mode t
                                             :input-process-increment 4
                                             :listdxx t))
                       (timevars (append
                                  (mapcar #'(lambda (x) 1) (butlast midicvars))
                                  (list (an-integer-betweenv 1 32)))))
                  (assert! (=v (last-atom midicvars) midic))
                  (assert! (apply 
                            #'andv
                            (mapcar #'(lambda (x)
                                        (andv (>=v x (cdr-assoc :midic-min params))
                                              (<=v x (cdr-assoc :midic-max params))))
                                    midicvars)))
                  (unless (< (length midicvars) 3)
                    (assert! (orv (apply #'<v (subseq midicvars (- (length midicvars) 3) (length midicvars)))
                                  (apply #'>v (subseq midicvars (- (length midicvars) 3) (length midicvars))))))
                  ;(assert! (list-n!pairs-/=v midicvars))
                  ;(let ((s (apply #'+v timevars)))
                  ;  (assert! (andv (>v s (* 2 timepoint)) (<=v s (* 4 timepoint))))
                  ;  (assert! (=v 0 (modv s (a-member-ofv '(3 4 5 7 ))))))
                  
                  (setf (cdr-assoc :expand-midic out-params) midicvars)
                  (setf (cdr-assoc :expand-timepoint out-params) (list timepoint timevars))
                  out-params))))
       :proto (let ((proto (funcall (cdr-assoc :HSEQ *export1-enppar-assoc*) params)))
                (setf (modulus proto) '(8 (1 1)))
                (setf (midic-csp-predicates proto)
                      (list 
                       #'(lambda (seqc)
                           (seqc-n!pairs-/=v (mapcar 
                                               #'(lambda (xs) 
                                                   (mapcar 
                                                    #'(lambda (x) (modv (-v (car x) (cadr x)) 12))
                                                    xs)) 
                                               (nPr seqc 2))))
                       #'(lambda (seqc)
                           (seqcx-ival-countv seqc 
                                              '((0 .0)
                                                (1 .12)
                                                (2 .7)
                                                (6 .3))))))
                (setf (time-csp-predicates proto)
                      (list 
                       #'(lambda (seqc) 
                           (seqc-n!pairs-/=v seqc))))
                proto))))

 ; RoboCop main theme by Basil Poledouris
 (cdr-assoc :H *export1-enppar-assoc*) 
 #'(lambda (params)
     (let ((reg (or (cdr-assoc :register params)
                    (cdr-assoc :reg params)
                    -1))
           (index (or (cdr-assoc :index params) 0)))
       (make-instance
        'timepoint-seqc-voice-with-prules
        :m* (or (cdr-assoc :m* params) 1)
        :midicrules '(;(:S 3 -3 :C :B nil)
                      (:S 3 -3 :C :B)
                      (:S :S :S)
                      (:C 3 5)
                      (:C 5 3)
                      (:C 3 3)
                      (:C -5)
                      (:B -9)
                      (:B -7)
                      (:B -5)
                      (:B -3)
                      (:B 0)
                      (:B 3)
                      (:B 5)
                      (:B 7)
                      (:B 9))
        :timerules '((:S 1 1 :C 1)
                     (:S 1 :C 1 1)
                     (:S 1 1 :C)
                     (:S 1 :C 1)
                     (:S :C)
                     (:C 2 3)
                     (:C 5)
                     (:C 1)
                     (:S :S :S))
        :params (list 
                 (cons :continue t)
                 (cons :mapprules-input-process-increment 9) ;9
                 (cons :mapprules-nondeterministic-values-cap nil) ;8
                 (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                 (cons :midic-min (apply #'min (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))
                 (cons :midic-max (apply #'max (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))))))
 (cdr-assoc :DD *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((reg (or (cdr-assoc :register params)
                    (cdr-assoc :reg params)
                    -1))
           (index (or (cdr-assoc :index params) 0)))
       (make-instance 'timepoint-seqc-voice-with-prules
                      :m* (or (cdr-assoc :m* params) 1)
                      :midicrules '((:S :A)
                                     (:S :B)
                                     (:S :C)
                                     (:S :C :S)
                                     (:S :E)
                                     (:S :E :S)
                                     (:S :G)
                                     (:S :H)
                                     (:A :J 2)
                                     (:A :A :D)
                                     (:A :A :E)
                                     (:A :A :F)
                                     (:A :A :G)
                                     (:A :D :A)
                                     (:A :E :A)
                                     (:A :F :A)
                                     (:A :G :A)
                                     (:B :I -2)
                                     (:B :B :B)
                                     (:I -1)
                                     (:I -2)
                                     (:I -3)
                                     (:I -4)
                                     (:I -5)
                                     (:I -6)
                                     (:J 1)
                                     (:J 2)
                                     (:J 3)
                                     (:J 4)
                                     (:J 5)
                                     (:J 6)
                                     (:C 3)
                                     (:D -3)
                                     (:D :D :A)
                                     (:D :D :D)
                                     (:E 2 1)
                                     (:E :E :E)
                                     (:E :E :G)
                                     (:F -2 -1)
                                     (:G 3)
                                     (:G :G :G)
                                     (:H -3))
                      :timerules '((:S 2)
                                   (:S 3)
                                   (:S :U)
                                   (:S :S :S)
                                   (:U 2 1 2)
                                   (:U :W)
                                   (:U :U :U)
                                   (:W 1 :X)
                                   (:W 1 1 :X)
                                   (:W :W :W)
                                   (:X 2)
                                   (:X 3)
                                   (:X 4)
                                   (:X 5))
                      :params (list                             
                               (cons :mapprules-input-process-increment 7) ;9
                               ;(cons :timerules-input-process-increment 5)
                               (cons :mapprules-nondeterministic-values-cap nil) ;8
                               (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                               (cons :midic-min (apply #'min (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))
                               (cons :midic-max (apply #'max (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))))))
 (cdr-assoc :D *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((reg (or (cdr-assoc :register params)
                    (cdr-assoc :reg params) ;
                    -1))
           (index (or (cdr-assoc :index params) 0)))
       (make-instance 'timepoint-seqc-voice-with-prules
                      :m* (or (cdr-assoc :m* params) 1)
                      :midicrules '((:S :A)
                                    (:S :B)
                                    (:S :C)
                                    (:S :C :S)
                                    (:S :E)
                                    (:S :E :S)
                                    (:S :G)
                                    (:S :H)
                                    (:A 2 4 1)
                                    (:A :A :D)
                                    (:A :A :E)
                                    (:A :A :F)
                                    (:A :A :G)
                                    (:A :D :A)
                                    (:A :E :A)
                                    (:A :F :A)
                                    (:A :G :A)
                                    (:B -1 -4 -2)
                                    (:B :B :B)
                                    (:C 1 3)
                                    (:D -1 -3)
                                    (:D :D :A)
                                    (:D :D :D)
                                    (:E 2 1)
                                    (:E :E :E)
                                    (:E :E :G)
                                    (:F -2 -1)
                                    (:G 1)
                                    (:G 2)
                                    (:G 3)
                                    (:G :G :G)
                                    (:H -3)
                                    (:H -2)
                                    (:H -1))
                      :timerules '((:S 2)
                                   (:S 3)
                                   (:S :U)
                                   (:S :S :S)
                                   (:U 2 1 2)
                                   (:U :W)
                                   (:U :U :U)
                                   (:W 1 :X)
                                   (:W 1 1 :X)
                                   (:W :W :W)
                                   (:X 2)
                                   (:X 3)
                                   (:X 4)
                                   (:X 5))
                      :params (mergeassoc (list                             
                                           (cons :mapprules-input-process-increment 7) ;9
                                          ;(cons :timerules-input-process-increment 5)
                                           (cons :mapprules-nondeterministic-values-cap nil) ;8
                                           (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                                           (cons :midic-min (apply #'min (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))
                                           (cons :midic-max (apply #'max (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg))))))))
                                          params))))
 (cdr-assoc :J *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((h (funcall (cdr-assoc :H *export1-enppar-assoc*) params)))
       (setf (cdr-assoc :midicrules-input-process-increment (params h)) 8)
       (setf (cdr-assoc :timerules-input-process-increment (params h)) 7)
       (setf (midicrules h)
             '((:S :O)
               (:S :P)
               (:S :T)
               (:S :S :S)
               (:T :P :O :R :Q)
               (:T :X :V :W :U)
               (:T :V :W)
               (:O 15)
               (:O 14)
               (:O 10)
               (:O 9)
               (:O 8)
               (:O 7)
               (:P -9)
               (:P -8)
               (:P -7)
               (:P -5)
               (:Q 8)
               (:Q 7)
               (:Q 5)
               (:Q 4)
               (:R -5)
               (:R -4)
               (:R -3)
               (:R -2)
               (:U -15)
               (:U -14)
               (:U -10)
               (:O -9)
               (:O -8)
               (:O -7)
               (:V 9)
               (:V 8)
               (:W 7)
               (:W 5)
               (:X 4)
               (:X 3)
               (:X 2)))
       (setf (timerules h)
             '((:S :V :U :X :W)
               (:S :V :W :X)
               (:S :U :X)               
               (:S 2)
               (:S :S :S)
               (:U 8)
               (:U 7)
               (:U 6)
               (:V 6)
               (:V 5)
               (:V 4)
               (:W 3)
               (:W 2)
               (:X 1)))
       h))

 (cdr-assoc :K *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((h (funcall (cdr-assoc :H *export1-enppar-assoc*) params)))
       (setf (cdr-assoc :midicrules-input-process-increment (params h)) 8)
       (setf (cdr-assoc :timerules-input-process-increment (params h)) 7)
       (setf (midicrules h)
             '((:S :O)
               (:S :P)
               (:S :T)
               (:S :S :S)
               (:T :P :O :R :Q)
               (:T :X :V :W :U)
               (:T :V :W)
               (:O 3)
               (:O 2)
               (:O 4 1)
               (:O 3 1)
               (:O 2 1)
               (:P -9)
               (:P -8)
               (:P -7)
               (:P -5)
               (:Q 8)
               (:Q 7)
               (:Q 5)
               (:Q 4)
               (:R -5)
               (:R -4)
               (:R -3)
               (:R -2)
               (:U -3)
               (:U -2)
               (:O -9)
               (:O -8)
               (:O -7)
               (:V 9)
               (:V 8)
               (:V -4 -1)
               (:V -3 -1)
               (:V -2 -1)
               (:W 7)
               (:W 5)
               (:X 4)
               (:X 3)
               (:X 2)))
       (setf (timerules h)
             '((:S :V :U :X :W)
               (:S :V :W :X)
               (:S :U :X)               
               (:S 2)
               (:S :S :S)
               (:U 8)
               (:U 7)
               (:U 6)
               (:V 6)
               (:V 5)
               (:V 4)
               (:W 3)
               (:W 2)
               (:X 1)))
       h))

 (cdr-assoc :F *export1-enppar-assoc*)
 #'(lambda (params)
     (let ((h (funcall (cdr-assoc :H *export1-enppar-assoc*) params)))
       (setf (cdr-assoc :midicrules-input-process-increment (params h)) 8)
       (setf (cdr-assoc :timerules-input-process-increment (params h)) 7)
       (setf (midicrules h)
             '((:S :O)
               (:S :P)
               (:S :T)
               (:S :S :S)
               (:T :O :P :Q :R)
               (:T :U :V :W :X)
               (:T :V :W)
               (:O 15)
               (:O 14)
               (:O 10)
               (:O 9)
               (:O 8)
               (:O 7)
               (:P -9)
               (:P -8)
               (:P -7)
               (:P -5)
               (:Q 8)
               (:Q 7)
               (:Q 5)
               (:Q 4)
               (:R -5)
               (:R -4)
               (:R -3)
               (:R -2)
               (:U -15)
               (:U -14)
               (:U -10)
               (:O -9)
               (:O -8)
               (:O -7)
               (:V 9)
               (:V 8)
               (:W 7)
               (:W 5)
               (:X 4)
               (:X 3)
               (:X 2)))
       (setf (timerules h)
             '((:S :U :V :W :X)
               (:S :U :V :W)
               (:S :V :W)               
               (:S 2)
               (:S :S :S)
               (:U 8)
               (:U 7)
               (:U 6)
               (:V 6)
               (:V 5)
               (:V 4)
               (:W 3)
               (:W 2)
               (:X 1)))
       h))
 (cdr-assoc :X *export1-enppar-assoc*)
 #'(lambda (params)
     (make-instance 'timepoint-seqc-voice-with-prules
                    :midicrules '((:S nil)
                                  (:S nil :S))
                    :timerules '((:S 8)
                                 (:S 8 :S)
                                 (:S 16)
                                 (:S 16 :S))))
 (cdr-assoc :CSEQ *export1-enppar-assoc*)
 #'(lambda (params)
     (make-instance 
      'csptech-timepoint-seqc
      :enps (mapcar 
             #'(lambda (es)
                 (make-instance
                  'multi-enppar
                  :enps (list es)))
             (cdr-assoc :enps params))
      :measures (cdr-assoc :measures params)
      :modulus (or (cdr-assoc :modulus params) '(8 (3 2)))
      :params params))
 (cdr-assoc :CD *export1-enppar-assoc*)
 #'(lambda (params)
     (make-instance 'csptech-timepoint-seqc-voice
                    :cspvar-function #'(lambda (obj) 
                                         (lprint 'ppaarraammss (params obj))
                                         (list (cons :midics (one-value '(60 62 64 65 67 69)))
                                               (cons :timepoints '(1 1 1 (1 (1 1 1))))))))
 (cdr-assoc :C *export1-enppar-assoc*)
 #'(lambda (params)
     (make-instance 
      'csptech-timepoint-seqc-voice
      :cspvar-function #'export1-seqc-d-cspvar-function
      :params (let ((reg (or (cdr-assoc :register params) -1))                    
                    (index (or (cdr-assoc :index params) 0)))
                (mergeassoc (list                             
                           ;(cons :mapprules-input-process-increment 7) ;9
                                          ;(cons :timerules-input-process-increment 5)
                           ;(cons :mapprules-nondeterministic-values-cap nil) ;8
                             (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                             (cons :midic-min (apply #'min (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg)))))))
                             (cons :midic-max (apply #'max (flat (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg))))))))
                            params))))
 (cdr-assoc :C1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :C14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :C *export1-enppar-assoc*) params))
 (cdr-assoc :I *export1-enppar-assoc*) 
 #'(lambda (params)
     (let ((reg (or (cdr-assoc :register params)
                    (cdr-assoc :reg params)
                    -1))
           (index (or (cdr-assoc :index params) 0)))
       (make-instance
        't2l::timepoint-seqc-voice-with-prules
        :m* (or (cdr-assoc :m* params) 1)
        :midicrules '(;(:S :D :C)
                      (:S :D :C)
                      (:S :S nil :S)
                      (:C -4)
                      (:C -3)
                      (:C -2 -1)
                      (:C -2 -2)
                      (:C -1)
                      (:C :C :C)
                      (:D 7)
                      (:D 8)
                      (:D 9)
                      (:D 10)
                      (:D 14)
                      (:D 15))
        :timerules '((:S :A)
                     (:S :B)
                     (:S :C)
                     (:S :S :B)
                     (:A 1 3 2)               
                     (:B 3 2 1)
                     (:C 2 1 3)
                     (:D 3))
        :params (list 
                 (cons :continuation-mode t)
                 (cons :mapprules-input-process-increment 9) ;9
                 (cons :mapprules-nondeterministic-values-cap nil) ;8
                 (cons :midic-start (make-intv= (apply #'export1-lkreg (append (list index) (if (listp reg) reg (list reg))))))
                 (cons :midic-min (car (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg))))))
                 (cons :midic-max (cadr (apply #'export1-lkreg2 (append (list index) (if (listp reg) reg (list reg))))))))))
 (cdr-assoc :D1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :D14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :D *export1-enppar-assoc*) params))
 (cdr-assoc :DD1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))
 (cdr-assoc :DD14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :DD *export1-enppar-assoc*) params))

 (cdr-assoc :J1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :J14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :J *export1-enppar-assoc*) params))
 (cdr-assoc :K1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :K14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :K *export1-enppar-assoc*) params))
 (cdr-assoc :H1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :H14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :H *export1-enppar-assoc*) params))
 (cdr-assoc :A1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :A14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :A *export1-enppar-assoc*) params))
 (cdr-assoc :F1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :F14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :F *export1-enppar-assoc*) params))
 (cdr-assoc :I1 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 1)
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I2 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 2)
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I3 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 3)
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I4 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) 4)
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I12 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 2))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I23 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 3))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I34 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(3 4))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I13 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 3))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I24 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(2 4))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
 (cdr-assoc :I14 *export1-enppar-assoc*)
 #'(lambda (params)
     (setf (cdr-assoc :register params) '(1 4))
     (funcall (cdr-assoc :I *export1-enppar-assoc*) params))
)

(defun export1-lkreg2 (index &rest keys)
  (let ((list (cdr-assoc index *export1-register-midic-assoc*)))
    (let ((ms (flat 
               (mapcar
                #'(lambda (k)
                    (cdr-assoc k list))
                keys))))
      (list (apply #'min ms) (apply #'max ms)))))

(defun export1-lkreg (index &rest keys)
  (let ((list (cdr-assoc index *export1-register-midic-assoc*)))
    (mapcar
     #'(lambda (k)
         (cdr-assoc k list))
     keys)))

(cl:defun export1-symbols->enppar (ps)
  (print (format nil "export1-symbols->enppar list: ~A" ps))
  (labels
      ((symbol->part-enppar (sym index &optional params)
         (cond
          ((listp sym)
           (symbol->part-enppar (car sym) index (cdr sym)))
          (t
           (assert (cdr-assoc sym *export1-enppar-assoc*))
           (setf (cdr-assoc :index params) index)
           (setf (cdr-assoc :symbol params) sym)
           (let ((obj (funcall (cdr-assoc sym *export1-enppar-assoc*) params)))
             (setf (cdr-assoc :index (params obj)) index)
             (setf (cdr-assoc :symbol (params obj)) sym)
             (setf (params obj) (mergeassoc params (params obj)))
             (fill-slots obj (params obj))
             obj))))
       (parts->enppar (list)
         (let ((enps (mapcar 
                      #'(lambda (s i) (symbol->part-enppar s i list))
                      (cdr-assoc :symbols list)
                      (om:arithm-ser 0 (1- (length (cdr-assoc :symbols list))) 1))))
           (dolist (e enps)
             (setf (params e) (mergeassoc list (params e))))
           (setf (cdr-assoc :enps list) enps)
           (funcall (cdr-assoc (car (or (cdr-assoc :sequence list) '(:HSEQ))) *export1-enppar-assoc*) list))))
    (make-instance 'multipart-enppar-sequence
                   :enps (mapcar #'parts->enppar ps))))
















(cl:defun export1-12ser-midic0127 (&key (series '(2 1 8 7 6 5 3 0 11 9 4 10)) (partn-list '(4 2 3 1 2)) (iterations 2) (start 0))
  (assert (= (length series) (tree-sum partn-list)))
  (if (>= *mess* 30) (lprint 'export1-12ser-midic0127 'series series 'partn-list partn-list 'iterations iterations))
  (let* 
      ((partn-list-perms (loop for i from 0 
                               while (< i (length partn-list))
                               collect (rotate partn-list i)))
       (series-idx-lists (loop for i from 0
                               while (< i (length partn-list-perms))
                               collect (maplist 
                                        #'(lambda (x)
                                            (let ((s (tree-sum (cdr x))))
                                              (list s (+ s (car x)))))
                                        (reverse (elt partn-list-perms i)))))
       (series-idx-list (flat series-idx-lists 1))
       (series-partn-list (loop for n in series-idx-list
                                collect (subseq series (car n) (cadr n))))
       (xpos-list '(0 12 24 36 48 60 72 84 96 108 120))
       (p start))
    (sort 
     (remove-duplicates 
      (flat
       (loop for i from 0
             for j = (mod i (length xpos-list))
             while (< i (* (length xpos-list) iterations))
             collect (progn
                       (setf p (mod (1+ p) (length series-partn-list)))
                       (om+ (pcset-cartx2 (elt series-partn-list p)
                                          (elt series-partn-list (mod (1+ p) (length series-partn-list))))
                            (elt xpos-list (mod i (length xpos-list)))))))
      :test #'=)
     #'<)))


(defvar *export1-ser0127-assoc* nil)
(setf (cdr-assoc 0 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 0) :iterations 3))
(setf (cdr-assoc 1 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 1) :iterations 3))
(setf (cdr-assoc 2 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 2) :iterations 3))
(setf (cdr-assoc 3 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 3) :iterations 3))
(setf (cdr-assoc 4 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 4) :iterations 3))
(setf (cdr-assoc 5 *export1-ser0127-assoc*)
      (export1-12ser-midic0127 :partn-list (om:rotate '(4 2 3 1 2) 5) :iterations 3))
          
  ;(let* ((series-idx-list (maplist #'(lambda (x)
  ;                                     (let ((s (tree-sum (cdr x))))
  ;                                       (list s (+ s (car x)))))
  ;                                 (reverse partn-list)))
  ;       (series-partn-lists (mapcar #'(lambda (x)
  ;                                      (subseq series (car x) (cadr x)))
  ;                                  series-idx-list)))
         ;(sets (mapcar #'(lambda (x) 
         ;                  (om+ (pcset-cartx2 partn1 partn2) x))
         ;              '(0 12 24 36 48 60 72 84 96 108 120))))
  ;  (flat 
  ;   (loop for i from 0
  ;         for j = )))

(defun spec1-xl-ival-members-var (list &key (ivalset '(3 4 5 7 8 9 -9 -8 -7 -5 -4 -3)))
  (seqc-xl-ival-members-var list :ivalset ivalset))
          
(defun demo-ms-soln1 (seqc) (ms-seqc-soln1 seqc))
(defun ms-soln1 (seqc) (ms-soln1 seqc))
(defun demo-seqc-ms-soln1 (seqc) (ms-seqc-soln1 seqc))
(defun ms-seqc-soln1 (seqc &optional (i 0))
  (let* ((vars (ms-template->vars (init-ms-template seqc)))
         (ratios (mapcar #'(lambda (x)
                             (ms-vars->ratios (caadr x)))
                         vars)))
    (assert! 
     (apply #'andv 
            (mapcar #'(lambda (x)
                        (apply #'=v (flat x)))
                    ratios)))
    (let ((soln (ith-value i (solution vars (static-ordering #'linear-force)))))
      (seqc->poly seqc soln))))
                        

(defun export1-arp2 (&key start-seqc
                          (root-length 3)
                          (root-template '((3) (-3) (5) (7) (-7) (9)))
                          (voice-template '((1) (-1) (2) (-2) (3) (-3)))
                          (min 38)
                          (max 58)
                          (voice-interval-min 6)
                          (xl-ival-list '(5 7 8 9 10 12))
                          sieve
                          nsucc
                          params)
  (let* ((init-start-seqc (if start-seqc
                              start-seqc
                            (let ((root (an-integer-betweenv 42 48))
                                  (a (an-integer-betweenv 7 9))
                                  (b (an-integer-betweenv 7 9)))
                              (list root
                                    (+v root a)
                                    (+v root a b)))))
         (template-list (append (list root-template)
                                (make-sequence 'list (1- (length init-start-seqc)) :initial-element voice-template)))
         (seqc (mapcar #'(lambda (x tmp)
                           (lprint 'x x 'tmp tmp)
                           (list-template->vars (make-sequence 'list root-length :initial-element "_") 
                                                tmp 
                                                :init x 
                                                :min min 
                                                :max max 
                                                :superset sieve))
                       init-start-seqc
                       template-list)))
    (if nsucc
        (mapcar #'(lambda (w)
                    (mapcar #'(lambda (x) (assert! (orv (all<v x) (all>v x))))
                            (nsucc w nsucc)))
                seqc))
    (if voice-interval-min
        (mapcar #'(lambda (x)
                    (assert! (>=v (apply #'minv (mapcar #'integer-absv (listdxv x))) voice-interval-min)))
                (mat-trans (flatten-seqc seqc))))
    (if (>= *mess* 30) (lprint 'voice-interval-min voice-interval-min))
    (if xl-ival-list 
        (mapcar #'(lambda (x) (assert! (all-memberv (listdxv x) xl-ival-list)))
                (mat-trans (flatten-seqc seqc))))
    (if (>= *mess* 30) (lprint 'xl-ival-list xl-ival-list))
    (flat (mat-trans (flatten-seqc seqc)))))

(defun partn->index-list (list)
  (reverse
   (maplist #'(lambda (x)
               (let ((a (find-sumof (cdr x))))
                 (list a
                       (+ a (car x)))))
           (reverse list))))

(defun export1-12ser-v2 (series partn-list)
  (an-integer-between 1 5))

(defun export1-midic0127-ser-superset (list set xpos)
  (apply #'andv (mapcar #'(lambda (x) (memberv (modv x 12) b)) flat)))

(defun export1-set-xpos-list-memberv-rule (input-list set idxlist xpos-list)
  (apply #'andv (mapcar #'(lambda (input xpos)
                            (export1-set-xpos-memberv-rule input set idxlist xpos))
                        input-list
                        xpos-list)))

(defun export1-set-xpos-memberv-rule (input set idxlist xpos)
  (all-memberv (flat input)
               (set->midic0127v 
                (list-modv12
                 (list+v (if idxlist 
                             (list-elt set idxlist) 
                           set)
                         xpos)))))

(defun assert-seqc-xl-sets-eqv (seqc sets)
  (assert-seqc-xl-sets-eqv seqc sets))
(defun assert!-seqc-xl-sets-eqv (seqc sets) ;iffy
  (dolist (x (mat-trans (flatten-seqc (apply-substitution seqc))))
    (pcset-reorder x (a-member-of sets)))
  seqc)
(defun export1-seqc-xl-sets-eqv-one-solution (seqc sets &optional force-function default)
  (one-value (assert!-seqc-xl-sets-eqv seqc sets) default))
(defun assert-no-duplicates (seqc)
  (assert!-no-duplicates seqc))
(defun assert!-no-duplicates (seqc)
  (assert! (export1-no-duplicates seqc)))
(defun export1-no-duplicates (seqc)
  (apply #'andv 
         (mapcar #'(lambda (x)
                     (remove nil (maplist #'(lambda (y)
                                              (cond ((cdr y) (notv (=v (car y) (cadr y))))
                                                    (t nil)))
                                          (flat x))))
                 (apply-substitution seqc))))
         
(defun export1-assert!-seqc2x-xl-ivals (seqc ivals)
  (assert! (export1-seqc2x-xl-ivals seqc ivals)))

(defun export1-seqc2x-xl-ivals (seqc ivals)
  (apply #'andv
         (mapcar #'(lambda (x)
                 (let* ((a (-v (cadr x) (car x)))
                        (b (funcallv #'abs a))
                        (c (funcallv #'mod b 12)))
                   (memberv c ivals)))
                  (mat-trans (flatten-seqc seqc)))))
(defun export1-assert!-seqc-voicex (seqc)
  (assert! (export1-seqc-voicex seqc)))

(defun export1-seqc-voicex (seqc)
  (apply #'andv 
         (mapcar #'(lambda (x)
                     (apply #'<=v x))
                 (mat-trans (flatten-seqc seqc)))))

  


(cl:defun export1-set-xpos011 (set)
  (mapcar #'(lambda (x) (cons x (mapcar #'(lambda (y) (mod y 12)) (om+ set x)))) (prime-facts 0 11 1)))



(defun export1-init-cf-prcs-fn (x)
  (dotimes (i (length x))
    (if (and (= (mod i 2) 0)
             (> i 4))
        (let ((e1 (elt x (- i 3)))
              (e2 (elt x i)))
          (assert! (=v e1 e2))))))

(defun export1-block4 (&key (temp2 '((-1 -3 -5 -7) (-1 -3 -5) (-1 -3 -4 -6) (-1 -2 -4)))
                            (temp1 '((3) (4) (5) (7) (8) (9) (-1) (-3) (-4) (-5) (-7) (-8) (-9)))
                            (iterations 6)
                            (init1 (an-integer-betweenv 71 76))
                            (init2 58)
                            (seqcxl-ivals '(2 3 4 5 6 7 8 9))
                            (seqcxl-max-ival 30)
                            flip1-
                            no-voicex
                            (cf-prcs-fn #'export1-init-cf-prcs-fn))
  (if (>= *mess* 20) (print (list 'export1-block4 5)))  
  (let* ((list1 (list-template->vars (make-sequence 'list iterations :initial-element '(_ _))
                              temp1
                              :init init1))
         (list2 (list-template->vars (make-sequence 'list iterations :initial-element '_)
                                     temp2
                                     :init init2))
         (seqc (list list1 list2))
         (seqcxl (mat-trans (flatten-seqc seqc))))
    (if (>= *mess* 20) (print (list 'export1-block4 10 'seqc seqc)))
    (funcall cf-prcs-fn (flat list1))
    (if (>= *mess* 20) (print (list 'export1-block4 20)))
    (dolist (x seqcxl) 
      (assert! (memberv (modv (integer-absv (-v (car x) (cadr x))) 12) seqcxl-ivals)))
    (if (>= *mess* 20) (print (list 'export1-block4 30)))
    (dolist (x seqcxl) 
      (assert! (<v (integer-absv (-v (car x) (cadr x))) seqcxl-max-ival)))
    (if (>= *mess* 20) (print (list 'export1-block4 40)))
    (if no-voicex
        (dolist (x seqcxl)
          (assert! (>v (car x) (cadr x)))))
    (if (>= *mess* 20) (print (list 'export1-block4 50)))
    seqc))
        
(cl:defun list-partitions1 (list partition-count)
  (assert (<= partition-count (length list)))
  (let* ((partition-size-floor (floor (/ (length list) 
                                         partition-count)))
         (remaining-size (- (length list) (* partition-count partition-size-floor)))
         (partition-list-left (make-sequence 'list partition-count :initial-element partition-size-floor))
         (partition-list (append (butlast partition-list-left)
                                 (list (+ (last-atom partition-list-left) remaining-size))))
         (index-list (partn->index-list partition-list)))
    (mapcar #'(lambda (x) (subseq list (car x) (cadr x))) index-list)))
(om::defmethod! escalier ((liste list) (pas integer))
  :initvals '('(1 2 3 4 5 6) 2)
  :indoc '("List" "Step")
  :icon 136
  :doc   "permute en escalier : si pas = 2 ,(1 2 3 4 5 6)  devient (1 3 2 4 3 5 4 6)"
  (let ((res))
    (dotimes (i (- (length liste)  pas))
      (push (nth i liste) res)
      (push (nth (+ i pas) liste) res))
    (nreverse res)))

;===Rename escalier as stairs 26-06-2007===================

(om::defmethod! stairs ((liste list) (step integer))
  :initvals '('(1 2 3 4 5 6) 2)
  :indoc '("List" "Step")
  :icon 136
  :doc   "Returns a permutation according to a stairs model. For example, with a stepsize equal to 2, the list (1 2 3 4 5 6) will become (1 3 2 4 3 5 4 6)."

  (escalier liste step))

(defun export2-delay-pairs (&key 
                            (length 12) 
                            (min 60)
                            (max 80) 
                            (prules '((:S 5 :A)
                                      (:S :A 5)
                                      (:S :S :S)
                                      (:A -9)
                                      (:A -8)
                                      (:A -7)
                                      (:A -5)
                                      (:A -4)
                                      (:A -3)
                                      (:A -2)
                                      (:A 2)
                                      (:A 3)
                                      (:A 4)
                                      (:A 5)
                                      (:A 7)))
                            (xpos nil)
                            (input-process-increment 2))

  (let ((s (mapcar #'(lambda (x) (an-integer-betweenv min max)) (make-sequence 'list length))))
    (assert! (mapprules s prules :listdxx t :input-process-increment input-process-increment))
    (let ((xpos1 (cond ((null xpos) (an-integer-betweenv 0 11))
                    ((listp xpos) (a-member-ofv xpos))
                    (t xpos))))
      (let ((s2 (funcall-rec #'(lambda (x) (+v x xpos1)) s)))
        (let ((ps (nsucc s 2 :step 2))
              (ps2 (rotate (nsucc s2 2 :step 2) -2)))
          (let* ((seqc (list (mapcar #'(lambda (xs) (list xs (list (cadr xs) (car xs)))) ps)
                            (mapcar #'(lambda (xs) (list (list (car xs) (cadr xs)) xs)) ps2)))
                 (cartx (remove-duplicates
                         (flat1
                          (mapcar 
                           #'(lambda (xs)
                               (remove-duplicates 
                                (remove-if #'(lambda (x) (eq (car x) (cadr x)))
                                           (cartesian-product xs xs))
                                :test #'set-difference-eq))
                           (mat-trans (flatten-seqc seqc))))
                         :test #'set-difference-eq))
                 (ivs (mapcar #'(lambda (xs) (modv (-v (car xs) (cadr xs)) 12)) cartx)))
            (assert! (all-memberv ivs '(2 3 4 5 6 7 8 9)))
            (values s xpos)))))))

    
    